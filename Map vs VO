VO에 getter, setter를 쓰는 경우

변수에 새로운 값을 할당할 때마다 validation(유효성 검사) 검사 가능
lazy loading(지연 로딩) 가능
read와 write 권한 다르게 설정 가능(public, private 사용)



Map vs VO

Map 사용 시

장점

개발 시 권장사항이 select 시에는 Map을 사용하여야 하는 경우 Map을 권장
select를 사용하는 경우는 보통 2개 이상의 테이블을 조인하여 조회하는 경우가 많아 VO로는 표현이 복잡하기 때문에 Map을 사용한다.

단점
Map의 key 또는 value가 null인 경우 Map은 해당 필드 자체를 key로 가져가지 않는다.
따라서 쿼리 수행 시, key 값 자체가 존재하지 않아 오류 발생 (이 경우를 대비하여 쿼리에 jdbcType 선언 필요, 
해당 값이 null일 경우 초기화 타입 지정) 여러 타입을 담아야 하기 때문에 Map은 Value 선언 시 Object로 할 수 밖에 없다.
그러나 Object는 최상위 타입이기 때문에 type이 매치되지 않는 경우가 발생해도 실제로 돌려보지 않는 한 알 수가 없다. 
Object로 선언하여 모든 타입을 담기 때문에, 부가적인 casting 작업이 발생 가능하다.



VO 사용 시

장점
비즈니스 로직 상 데이터가 명확해야 하는 경우 VO 권장 (ex: 정산, 공수 산정, 매표 등)
특정 값의 key 또는 value(필수 값인 경우)가 null 인 경우 VO 클래스 내에 선언된 타입으로 초기화 수행됨. 쿼리 수행 시 null로 인한 오류가 나지 않음
멤버변수에 대한 구체적인 타입을 선언하기 때문에 타입이 매치되지 않는 경우 컴파일 에러가 발생하여 바로 알아챌 수 있다.
반드시 값이 필요한 변수에 대해 생성자 파라미터로 필요한 값을 넣을 수 있어, 이 값이 없는 경우 컴파일 에러가 발생한다.

단점
Map에 비해 소스가 많아진다.
getter, setter 메서드를 일일이 작성해주어야 하는 번거로움이 있었지만 현재 Lombock을 사용하면 
annotation 형태로 조금 더 간편하게 사용 할 수 있다 (@Getter, @Setter)
